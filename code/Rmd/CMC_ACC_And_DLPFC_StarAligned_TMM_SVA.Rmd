---
title: "Covariate analysis of CMC RNASeq data reprocessed with Star-Feature counts pipeline (ACC and DLPFC with TMM normlaisation and SVA)"
author: "Thanneer Perumal"
date: "`r date()`"
output: html_document
---
```{r knit2synapse, eval=FALSE}
library(knitr)
library(knit2synapse)
library(synapseClient)

synapseLogin()

knit2synapse::knitToFolderEntity(file = "./CMC_ACC_And_DLPFC_StarAligned_TMM_SVA.Rmd",
                                 parentId ="syn7501880",
                                 entityName = 'ACC and DLPFC - STAR Reprocessed - with TMM - SVA')
```

```{r libs, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
## It is assumed your working directory is where this file

## Load required libraries
library(CovariateAnalysis) # get it from devtools::install_github('th1vairam/CovariateAnalysis@dev')
library(data.table)
library(tidyr)
library(plyr)
library(dplyr)
library(stringr)

library(ggplot2)
library(reshape2)
library(limma)
library(Biobase)
library(gplots)
library(WGCNA)
library(psych)
library(edgeR)
library(biomaRt)
library(RColorBrewer)
library(sva)

library(synapseClient)
library(knitr)
library(githubr)

library(foreach)
library(doParallel)

cl = makeCluster(14)
registerDoParallel(cl)

synapseLogin()

## Requires ggdendro
devtools::source_url("https://raw.githubusercontent.com/chr1swallace/random-functions/master/R/ggplot-heatmap.R")

options(xtable.type="html")

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE)
```

```{r synapse.parameters, include=FALSE, cache=TRUE}
# Synapse parameters
parentId = 'syn7501880';
activityName = 'Covariate adjustments';
activityDescription = 'Covariate analysis of star aligned CMC reprocessed RNASeq data with TMM normalisation and SVA (ACC and DLPFC)';

thisFileName <- 'CMC_ACC_And_DLPFC_StarAligned_TMM_SVA.Rmd'

# Github link
thisRepo <- getRepo(repository = "th1vairam/Brain_Reg_Net", ref="branch", refName='CMC')
thisFile <- getPermlink(repository = thisRepo, repositoryPath=paste0('code/Rmd/',thisFileName))
```
### Data download
#### Obtain count matrix and metadata from synapse.
```{r download.data, cache=TRUE}
# Download reprocessed counts (ACC)
COUNT_ACC_ID = 'syn7217917';
ALL_USED_IDs = COUNT_ACC_ID
COUNT_ACC = read.table(synGet(COUNT_ACC_ID)@filePath, header=T, sep='\t', check.names = F, nrows = 56632) %>%
  dplyr::select(-chr, -start, -end, -strand, -length)

# Download reprocessed counts (DLPFC)
COUNT_DLPFC_ID = 'syn7217916';
ALL_USED_IDs[length(ALL_USED_IDs)+1] = COUNT_DLPFC_ID
COUNT_DLPFC = read.table(synGet(COUNT_DLPFC_ID)@filePath, header=T, sep='\t', check.names = F, nrows = 56632) %>%
  dplyr::select(-chr, -start, -end, -strand, -length)

COUNT = join_all(list(COUNT_ACC, COUNT_DLPFC), type = 'full')
rownames(COUNT) = COUNT$geneID
COUNT$geneID = NULL
COUNT = data.matrix(COUNT)

# Get merged metadata
METADATA_ID = 'syn2299154'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = METADATA_ID
METADATA = read.csv(synGet(METADATA_ID)@filePath, fill = T, header = F)

# Get ancestry vector calculated using gemtools
ANCESTRY_ID = 'syn2511399'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = ANCESTRY_ID
ANCESTRY = read.table(synGet(ANCESTRY_ID)@filePath, fill = T, header = T, sep = '\t') %>%
  plyr::rename(c('DNA_report..Genotyping.Sample_ID' = 'GenotypingSampleID'))

## Metadata with specific information for RNASeq processing
metadataVarOfInterest = c("Individual ID", "Institution", "Gender", "Age of Death", "PMI (in hours)", 
                          "Dx", "ACC_RNA_isolation: Exclude?", "ACC_RNA_isolation: Sample RNA ID",
                          "ACC_RNA_isolation: RIN", "ACC_RNA_report: Exclude?", "ACC_RNA_report: Library Batch",
                          "DLPFC_RNA_isolation: Exclude?", "DLPFC_RNA_isolation: Sample RNA ID",
                          "DLPFC_RNA_isolation: RIN", "DLPFC_RNA_report: Exclude?", "DLPFC_RNA_report: Library Batch",
                          'DNA_genotyping_report: Genotyping Sample_ID')

# Filter metadata 
ind = as.character(METADATA[1,] %>% unlist) %in% metadataVarOfInterest
METADATA = METADATA[,ind]
colnames(METADATA) = gsub('[^[:alnum:]]','_',as.character(METADATA[1,] %>% unlist))

METADATA_ACC = METADATA %>%
  dplyr::select(Individual_ID, Institution, Gender, Age_of_Death, PMI__in_hours_, Dx, ACC_RNA_isolation__Exclude_,
                ACC_RNA_isolation__Sample_RNA_ID, ACC_RNA_isolation__RIN, ACC_RNA_report__Exclude_,
                ACC_RNA_report__Library_Batch, DNA_genotyping_report__Genotyping_Sample_ID) %>%
  dplyr::rename(PMI = PMI__in_hours_, 
                IsolationExclude = ACC_RNA_isolation__Exclude_, 
                SampleID = ACC_RNA_isolation__Sample_RNA_ID, 
                RIN = ACC_RNA_isolation__RIN, 
                ReportExclude = ACC_RNA_report__Exclude_, 
                LibraryBatch = ACC_RNA_report__Library_Batch,
                GenotypingSampleID = DNA_genotyping_report__Genotyping_Sample_ID) %>%
  dplyr::filter(SampleID %in% colnames(COUNT)) %>%
  dplyr::mutate(Tissue = 'ACC')

METADATA_DLPFC = METADATA %>%
  dplyr::select(Individual_ID, Institution, Gender, Age_of_Death, PMI__in_hours_, Dx, DLPFC_RNA_isolation__Exclude_,
                DLPFC_RNA_isolation__Sample_RNA_ID, DLPFC_RNA_isolation__RIN, DLPFC_RNA_report__Exclude_,
                DLPFC_RNA_report__Library_Batch, DNA_genotyping_report__Genotyping_Sample_ID) %>%
  dplyr::rename(PMI = PMI__in_hours_, 
                IsolationExclude = DLPFC_RNA_isolation__Exclude_, 
                SampleID = DLPFC_RNA_isolation__Sample_RNA_ID, 
                RIN = DLPFC_RNA_isolation__RIN, 
                ReportExclude = DLPFC_RNA_report__Exclude_, 
                LibraryBatch = DLPFC_RNA_report__Library_Batch,
                GenotypingSampleID = DNA_genotyping_report__Genotyping_Sample_ID) %>%
  dplyr::filter(SampleID %in% colnames(COUNT)) %>%
  dplyr::mutate(Tissue = 'DLPFC')

METADATA = rbindlist(list(METADATA_ACC, METADATA_DLPFC), use.names = T, fill = T) %>%
  droplevels() %>%
  dplyr::mutate(LibraryBatch = as.factor(LibraryBatch)) %>%
  left_join(ANCESTRY)

# Replace AFF and BP samples as other
levels(METADATA$Dx) = c("Other", "Other", "Control", "SCZ")
```

### Data preprocessing
```{r preprocess.data}
# Remove samples marked as exclude and samples with no Gender, Ethnicity, PMI, and RIN
writeLines('Following counts are missing any metadata')
writeLines(paste(setdiff(colnames(COUNT), levels(METADATA$SampleID)), collapse = ', '))
METADATA <- METADATA %>% filter(SampleID %in% colnames(COUNT)) 

writeLines('Following samples are marked exclude')
writeLines(paste(METADATA$SampleID[METADATA$IsolationExclude == 1 | METADATA$ReportExclude == 1], collapse = ', '))
METADATA <- METADATA  %>% filter(IsolationExclude == 0, ReportExclude == 0) 

writeLines('Following samples are missing PMI information')
writeLines(paste(METADATA$SampleID[is.na(METADATA$PMI)], collapse = ', '))
METADATA <- METADATA  %>% filter(!is.na(PMI)) 

writeLines('Following samples are missing gender information')
writeLines(paste(METADATA$SampleID[is.na(METADATA$Gender)], collapse = ', '))
METADATA <- METADATA  %>% filter(!is.na(Gender)) 

writeLines('Following samples are missing RIN information')
writeLines(paste(METADATA$SampleID[is.na(METADATA$RIN)], collapse = ', '))
METADATA <- METADATA  %>% filter(!is.na(RIN)) 

writeLines('Following samples are missing EV information')
writeLines(paste(METADATA$SampleID[is.na(METADATA$EV.1)], collapse = ', '))
METADATA <- METADATA  %>% filter(!is.na(METADATA$EV.1)) 
```

```{r preprocess.data1, results='asis'}
# Match covariates to expression data
indToRetain = intersect(METADATA$SampleID, colnames(COUNT))
removedIDs = setdiff(colnames(COUNT), METADATA$SampleID)

COUNT = COUNT[,indToRetain]

rownames(METADATA) = METADATA$SampleID
METADATA = METADATA[indToRetain,]

METADATA %>% 
  group_by(Dx, Tissue) %>% 
  summarise(count = n()) %>% 
  spread(Tissue, count) %>%
  kable()

METADATA = METADATA %>%
  dplyr::mutate(Dx.Tissue = paste(Dx, Tissue, sep = '.'))
```
Following sample are removed `r paste(removedIDs, collapse = ',')`

### Covariate clustering
Determine relationship between covariates. 
```{r covariates.clustering}
FactorCovariates <- c("Individual_ID", "Institution", "Gender", "LibraryBatch", "Dx.Tissue")
ContCovariates <- c("Age_of_Death", "PMI", "RIN", "EV.1", "EV.2", "EV.3", "EV.4", "EV.5")

# Find inter relation between factor covariates
COVARIATES = METADATA[,c(FactorCovariates,ContCovariates),drop=F]
COVARIATES[,FactorCovariates] <- data.frame(lapply(COVARIATES[,FactorCovariates],function(x){x <- sapply(x,function(y){str_replace_all(as.character(y),'[^[:alnum:]]','_')})}))
rownames(COVARIATES) <- METADATA$SampleID

# Convert factor covariates to factors
COVARIATES[,FactorCovariates] = lapply(COVARIATES[,FactorCovariates], factor)
COVARIATES[,ContCovariates] = lapply(COVARIATES[,ContCovariates], as.character)
COVARIATES[,ContCovariates] = lapply(COVARIATES[,ContCovariates], as.numeric)

# Add in RIN^2 values
COVARIATES$RIN2 = COVARIATES$RIN^2
ContCovariates = c(ContCovariates, 'RIN2')
```

Correlation/association between covariates at an FDR <= 0.1

```{r covariates.correlation, fig.width=8, fig.height=8}
ind.cov = setdiff(colnames(COVARIATES), 'Individual_ID')
COVARIATES.CORRELATION = getAssociationStatistics(COVARIATES[,ind.cov], PVAL = 0.05)
ggheatmap.show(COVARIATES.CORRELATION$plot, col.width=0.5, row.width=0.1)
```

Explore metatdata

```{r dataExplore, fig.width = 6, fig.height = 15}
my.theme <- theme(legend.position = 'top', axis.text.x = element_text(angle = 90, hjust = 1))

# RIN
p = list()
p[[1]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = RIN)) + geom_boxplot()
p[[1]] = p[[1]] + ggtitle('RIN') + my.theme

# Age of Death
p[[2]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = Age_of_Death)) + geom_boxplot()
p[[2]] = p[[2]] + ggtitle('AgeOfDeath') + my.theme

# PMI
p[[3]] = ggplot(COVARIATES, aes(x = Dx.Tissue, y = PMI)) + geom_boxplot()
p[[3]] = p[[3]] + ggtitle('PMI (in hours)') + my.theme

multiplot(plotlist = p, cols = 1)
```
### CPM Normalisation
Preprocess counts matrix and metadata. Determine design matrix for normalisation and differential expression analysis. 

Remove genes that have less than 1 cpm counts in at least 50% of samples per Dx.Tissue
```{r cpmnormalisation}
genesToAnalyze = dlply(METADATA, .(Dx.Tissue), .fun = function(mtd, count){
  processed.counts = getGeneFilteredGeneExprMatrix(count[,mtd$SampleID %>% droplevels()],
                                                   MIN_GENE_CPM=1, 
                                                   MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0.5)
  processed.counts$filteredExprMatrix$genes
}, COUNT)
genesToAnalyze = unlist(genesToAnalyze) %>% unique()

PROCESSED_COUNTS = getGeneFilteredGeneExprMatrix(COUNT[genesToAnalyze, ], MIN_GENE_CPM=0, MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0)
```
Processing `r dim(PROCESSED_COUNTS$filteredExprMatrix)[1]` genes in `r dim(PROCESSED_COUNTS$filteredExprMatrix)[2]` samples

### Normalisation (with NULL)
Initial normalisation usign voom (with NULL design)
```{r initial.voom.normalisation, fig.height=5, fig.width=5}
# TMM normalisation
TMM.GENE_EXPRESSION = calcNormFactors(PROCESSED_COUNTS$filteredExprMatrix, method = 'TMM')

# Initial normalisation of gene expression
VOOM.GENE_EXPRESSION = voom(TMM.GENE_EXPRESSION, design=NULL, plot=T)

# Set gene counts in specific samples that are deviating 3 sd from other samples to NA
log.mat = apply(VOOM.GENE_EXPRESSION$E, 1, function(x){
  mn = mean(x, na.rm = T)
  std.dev = sd(x, na.rm = T)
  return((x < (mn-3*std.dev)) | (x > (mn+3*std.dev)))
}) %>% t
PROCESSED_COUNTS$filteredExprMatrix[log.mat] = NA

# TMM normalisation
TMM.GENE_EXPRESSION = calcNormFactors(PROCESSED_COUNTS$filteredExprMatrix, method = 'TMM')

# Initial normalisation of gene expression
VOOM.GENE_EXPRESSION = voom(TMM.GENE_EXPRESSION, design=NULL, plot=T)
```
Coexpression of genes 
```{r coexp1, cache=FALSE, fig.height=5, fig.width=5}
cr = cor(t(VOOM.GENE_EXPRESSION$E))
hist(cr, main = 'Distribution of correlation between genes', xlab = 'Correlation')
```
### Outlier analysis
Clustering of voom adjusted data (with NULL design)
```{r decompse.normalise.data, fig.height=8, fig.width=8, results='asis'}
# Find principal components of expression to plot
PC <- prcomp(VOOM.GENE_EXPRESSION$E, scale.=T, center = T)

# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])

plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID'))

p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(color=Institution, shape=Dx.Tissue, size=Age_of_Death))
p <- p + theme_bw() + theme(legend.position="top")
# p <- p + geom_text(aes(label= SampleID), size=4, hjust=0)
p
```
Tree based classification of samples
```{r decompse.normalise.data.1, fig.height=6, fig.width=10, results='asis'}
# Eucledian tree based analysis
COVARIATES.tmp = data.matrix(COVARIATES[,c('Institution', 'Dx.Tissue')])
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0

tree = hclust(as.dist(t(VOOM.GENE_EXPRESSION$E)))
cols = WGCNA::labels2colors(COVARIATES.tmp);

WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp[,c('Institution', 'Dx.Tissue')]))
```

```{r temp, include = F}
dev.off()
gc()
```

### Significant Covariates
Correlation between pca of unadjusted mRNA expression and covariates is used to find significant covariates
```{r preAdjusted.covariates, cache=TRUE}
# Find correlation between PC's of gene expression with covariates
preAdjustedSigCovars = runPCAandPlotCorrelations(VOOM.GENE_EXPRESSION$E, 
                                                 COVARIATES[,ind.cov],
                                                 'NULL design(voom-normalized)', 
                                                 isKeyPlot=TRUE, 
                                                 MIN_PVE_PCT_PC = 1)
```

Significant covariates to adjust at FDR 0.1 are `r preAdjustedSigCovars$significantCovars`
```{r preAdjustedSigCovars.NULL, fig.width=20, fig.height=12}
preAdjustedSigCovars[["PC_res"]][[2]]$plotData
```

### Normalisation (custom design)
Normalising COUNTS with a design matrix obtained from an iterative normalisation analysis (see syn7503251 for more details). 

Here Institution, Gender, RIN, Age\\_of\\_Death, PMI, EV.4 were used as fixed effects conditioned on Dx.Tissue with Individual\\_ID as random effects.
```{r customNorm, results='asis'}
# Primary variable of interest
postAdjustCovars = c('Dx.Tissue', 'Institution', 'Gender', 'RIN', 'Age_of_Death', 'PMI', 'EV.4');

writeLines(paste('Using following covariates in the model:',
                 paste(postAdjustCovars, collapse=', '),
                 'as fixed effects and Individual_ID as random effect'))
  
# Post adjusted design matrix
DM1 = getDesignMatrix(COVARIATES[,postAdjustCovars,drop=F],Intercept = F)
DM1$design = DM1$design[,linColumnFinder(DM1$design)$indepCols]
  
# Estimate voom weights
VOOM.ADJUSTED.GENE_EXPRESSION = voom(TMM.GENE_EXPRESSION, design=DM1$design, plot=F)
correlation <- parallelDuplicateCorrelation(VOOM.ADJUSTED.GENE_EXPRESSION, block = COVARIATES$Individual_ID)
  
# Re-calculate voom weights with correlation of random effects
VOOM.ADJUSTED.GENE_EXPRESSION = voom(TMM.GENE_EXPRESSION, design=DM1$design, plot=F,
                                     block = COVARIATES$Individual_ID, 
                                     correlation = correlation$cor)

# Fit linear model using new weights and new design
VOOM.ADJUSTED.FIT = lmFit(VOOM.ADJUSTED.GENE_EXPRESSION)
  
# Residuals after normalisation
RESIDUAL.GENE_EXPRESSION = residuals.MArrayLM(VOOM.ADJUSTED.FIT,VOOM.ADJUSTED.GENE_EXPRESSION$E)
  
# Find PC of residual gene expression and significant covariates that are highly correlated with PCs
residualSigCovars = runPCAandPlotCorrelations(RESIDUAL.GENE_EXPRESSION, 
                                              COVARIATES[, ind.cov, drop=F], 
                                              'adjusted design(voom-normalized)',
                                              isKeyPlot=TRUE)
```

### Sanity check
```{r residualSigCovars.manual, fig.width=12, fig.height=8}
residualSigCovars[["PC_res"]][[2]]$plotData
```

### Estimate surrogate variables using SVA package
```{r svaAdjust}
MODEL0 = DM1$design[,-grep('Dx.Tissue',colnames(DM1$design))] # Get null model by removing variable of interest
MODEL1 = DM1$design

## Calculate the number of surrogate variables
NUM.SV = sva::num.sv(VOOM.ADJUSTED.GENE_EXPRESSION$E, MODEL1,
                     method = 'be', seed = 123456, B = 20)

SURR.VAR = sva::sva(VOOM.ADJUSTED.GENE_EXPRESSION$E, MODEL1, MODEL0,
                    n.sv = NUM.SV, B = 30)$sv
colnames(SURR.VAR) = paste0('SV',1:dim(SURR.VAR)[2])

DM1$design = cbind(MODEL1, SURR.VAR)

# Estimate voom weights
VOOM.ADJUSTED.GENE_EXPRESSION = voom(TMM.GENE_EXPRESSION, design=DM1$design, plot=F)
correlation <- parallelDuplicateCorrelation(VOOM.ADJUSTED.GENE_EXPRESSION, block = COVARIATES$Individual_ID)
  
# Re-calculate voom weights with correlation of random effects
VOOM.ADJUSTED.GENE_EXPRESSION = voom(TMM.GENE_EXPRESSION, design=DM1$design, plot=F,
                                     block = COVARIATES$Individual_ID, 
                                     correlation = correlation$cor)

# Fit linear model using new weights and new design
VOOM.ADJUSTED.FIT = lmFit(VOOM.ADJUSTED.GENE_EXPRESSION)
  
# Residuals after normalisation
RESIDUAL.GENE_EXPRESSION = residuals.MArrayLM(VOOM.ADJUSTED.FIT,VOOM.ADJUSTED.GENE_EXPRESSION$E)
  
# Find PC of residual gene expression and significant covariates that are highly correlated with PCs
residualSigCovars = runPCAandPlotCorrelations(RESIDUAL.GENE_EXPRESSION, 
                                              COVARIATES[, ind.cov, drop=F], 
                                              'adjusted design(voom-normalized)',
                                              isKeyPlot=TRUE)
```
### Residual calculation
Calculate weighted residuals and add back "Dx.Tissue" to the residuals
```{r varsToAddBack}
# Add variable of interest back to the residuals
varsToAddIn = grep("Dx.Tissue", colnames(DM1$design), value = T)
RESIDUAL.GENE_EXPRESSION = RESIDUAL.GENE_EXPRESSION + 
  VOOM.ADJUSTED.FIT$coefficients[,varsToAddIn] %*% t(DM1$design[,varsToAddIn])
```
Coexpression of genes 
```{r coexp2, cache=FALSE, fig.height=5, fig.width=5}
cr = cor(t(RESIDUAL.GENE_EXPRESSION))
hist(cr, main = 'Distribution of correlation between genes', xlab = 'Correlation')
```

### Clustering residual data
```{r decompse.normalise.data2, fig.height=8, fig.width=8, results='asis'}
# Find principal components of expression to plot
PC <- prcomp(RESIDUAL.GENE_EXPRESSION, scale.=T, center = T)

# Plot first 4 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])

plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID'))

p <- ggplot(plotdata, aes(x=PC1, y=PC2)) 
p <- p + geom_point(aes(color=Institution, shape = Dx.Tissue, size=RIN)) 
p <- p + theme_bw() + theme(legend.position="top")
# p <- p + geom_text(aes(label= SampleID), size=4, hjust=1)
p
```

```{r decompse.normalise.data2.1, fig.height=8, fig.width=12, results='asis'}
# Eucledian tree based analysis
COVARIATES.tmp = data.matrix(COVARIATES[,c('Dx.Tissue','Institution')])
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0

tree = hclust(as.dist(t(VOOM.GENE_EXPRESSION$E)))
cols = WGCNA::labels2colors(COVARIATES.tmp);

WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp[,c('Dx.Tissue','Institution')]))
```

```{r temp1, include=F}
dev.off()
gc()
```

```{r get.gene.symbols, cache=TRUE, eval=T}
backgroundGenes = data.frame(ensembl_gene_id = rownames(COUNT))

# Define biomart object
mart <- useMart(biomart = "ENSEMBL_MART_ENSEMBL", host = "mar2016.archive.ensembl.org", dataset = "hsapiens_gene_ensembl")

# Query biomart
Ensemble2HGNC <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol"),
                       filters = "ensembl_gene_id", values = backgroundGenes$ensembl_gene_id,
                       mart = mart)

# Add gene names
RESIDUAL.GENE_EXPRESSION <- RESIDUAL.GENE_EXPRESSION %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  left_join(Ensemble2HGNC) %>%
  dplyr::select(ensembl_gene_id, hgnc_symbol, one_of(rownames(COVARIATES)))

VOOM.ADJUSTED.GENE_EXPRESSION$E <- VOOM.ADJUSTED.GENE_EXPRESSION$E %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  left_join(Ensemble2HGNC) %>%
  dplyr::select(ensembl_gene_id, hgnc_symbol, one_of(rownames(COVARIATES)))
```

### Differential expression analysis
Genes that are differentially expressed at an FDR <= 0.05 are
```{r diffExp, fig.height=16, fig.width=16}
# Fit contrast
contrast = makeContrasts(contrasts=c("Dx.TissueControl_ACC-Dx.TissueOther_ACC",
                                     "Dx.TissueControl_ACC-Dx.TissueSCZ_ACC",
                                     "Dx.TissueOther_ACC-Dx.TissueSCZ_ACC",
                                     "Dx.TissueControl_DLPFC-Dx.TissueOther_DLPFC",
                                     "Dx.TissueControl_DLPFC-Dx.TissueSCZ_DLPFC",
                                     "Dx.TissueOther_DLPFC-Dx.TissueSCZ_DLPFC"),
                         levels = colnames(VOOM.ADJUSTED.FIT$coefficients))
FIT.CONTR = contrasts.fit(VOOM.ADJUSTED.FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)

# Get differnetial expression
DE = lapply(1:6, function(i, FIT, VOOM.ADJUSTED.GENE_EXPRESSION, Ensemble2HGNC){
  topTable(FIT.CONTR, coef=i, number = dim(VOOM.ADJUSTED.GENE_EXPRESSION$E)[1]) %>%
    rownameToFirstColumn('ensembl_gene_id') %>%
    left_join(Ensemble2HGNC) %>%
    dplyr::select(ensembl_gene_id, hgnc_symbol, logFC, AveExpr, t, P.Value, adj.P.Val, B)
}, FIT, VOOM.ADJUSTED.GENE_EXPRESSION, Ensemble2HGNC) 
names(DE) = colnames(contrast)

DE = DE %>% 
  rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Comparison = gsub('Dx.Tissue','',Comparison)) %>%
  tidyr::separate(Comparison, into = c('ref.state','to.state'), sep = '-') %>%
  tidyr::separate(ref.state, into = c('Dx1','Tissue'), sep = '_') %>%
  tidyr::separate(to.state, into = c('Dx2','Tissue'), sep = '_') %>%
  tidyr::unite(Comparison, Dx1, Dx2, sep = '_vs_') %>%
  dplyr::mutate(Direction = logFC/abs(logFC),
                Direction = factor(Direction, c(-1,1), c('-1' = 'DOWN', '1' = 'UP')))

tmp = DE %>%
  dplyr::filter(adj.P.Val <= 0.05) %>%
  dplyr::select(ensembl_gene_id, Comparison, Tissue, Direction) %>%
  group_by(Comparison, Tissue, Direction) %>%
  dplyr::summarise(FDR_0_05 = length(unique(ensembl_gene_id))) %>%
  spread(Direction, FDR_0_05) 

tmp1 = DE %>%
  dplyr::filter(adj.P.Val <= 0.05, abs(logFC) >= log2(1.2)) %>%
  dplyr::select(ensembl_gene_id, Comparison, Tissue, Direction) %>%
  group_by(Comparison, Tissue, Direction) %>%
  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(ensembl_gene_id))) %>%
  spread(Direction, FDR_0_05_FC_1.2) 

kable(full_join(tmp %>%
                  dplyr::rename(DOWN_FDR_0_05 = DOWN, UP_FDR_0_05 = UP),
                tmp1 %>%
                  dplyr::rename(DOWN_FDR_0_05_FC_1.2 = DOWN, UP_FDR_0_05_FC_1.2 = UP)))

p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC)) + geom_point() + xlim(c(-1,1))
p = p + geom_hline(yintercept = -log10(0.05), color = 'red') 
p = p + geom_vline(xintercept = log2(1.2), color = 'red') 
p = p + geom_vline(xintercept = -log2(1.2), color = 'red') 
p = p + facet_grid(Tissue+.~Comparison, scales = 'fixed')
p
```


### Store files in synapse
```{r synapse.store, include=FALSE, eval=TRUE, cache=FALSE}
# Code
CODE <- Folder(name = "ACC and DLPFC - STAR Reprocessed - with TMM - SVA", parentId = parentId)
CODE <- synStore(CODE)

# Store covariates
COVARIATES = rownameToFirstColumn(COVARIATES, 'SampleID')
write.table(COVARIATES, file = 'CMC_ACC_Covariates.tsv', sep = '\t', row.names=F, quote=F)
COV_OBJ = File('CMC_ACC_Covariates.tsv', name = 'Covariates', parentId = CODE$properties$id)
COV_OBJ = synStore(COV_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                   executed = thisFile, activityDescription = activityDescription)

# Store logCPM
write.table(VOOM.ADJUSTED.GENE_EXPRESSION$E, file = 'CMC_ACC_logCPM.tsv', sep = '\t', row.names=F, quote=F)
COUNT_OBJ = File('CMC_ACC_logCPM.tsv', name = 'Raw counts (logCPM)', parentId = CODE$properties$id)
COUNT_OBJ = synStore(COUNT_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                     executed = thisFile, activityDescription = activityDescription)

# Store design matrix
write.table(DM1$design, file = 'CMC_ACC_Design.tsv', sep = '\t', row.names=F, quote=F)
DM_OBJ = File('CMC_ACC_Design.tsv', name = 'Design Matrix', parentId = CODE$properties$id)
DM_OBJ = synStore(DM_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                  executed = thisFile, activityDescription = activityDescription)

# Store residual gene expression
write.table(RESIDUAL.GENE_EXPRESSION, file = 'CMC_ACC_Expression.tsv', sep = '\t', row.names=F, quote=F)
EXP_OBJ = File('CMC_ACC_Expression.tsv', name = 'Normalised Adjusted Residual Expression (Dx added)', parentId = CODE$properties$id)
EXP_OBJ = synStore(EXP_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                   executed = thisFile, activityDescription = activityDescription)

# Store differential expression results
write.table(DE, file = 'CMC_ACC_DiffExpression.tsv', sep = '\t', row.names=F, quote=F)
DEXP_OBJ = File('CMC_ACC_DiffExpression.tsv', name = 'Differential Expression Analysis', parentId = CODE$properties$id)
DEXP_OBJ = synStore(DEXP_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                    executed = thisFile, activityDescription = activityDescription)
stopCluster(cl)
```
|  *Results*                |  *SynapseID*                     |
|  -------                  |   ---------                      |
|  Covariates               |  `r COV_OBJ$properties$id`       |
|  Raw counts (log CPM)     |  `r COUNT_OBJ$properties$id`     |
|  Design Matrix            |  `r DM_OBJ$properties$id`        |
|  Residual Expression      |  `r EXP_OBJ$properties$id`       |
|  Differential Expression  |  `r DEXP_OBJ$properties$id`      |