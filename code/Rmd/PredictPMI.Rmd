---
title: "Prediction model for PMI using ROSMAP and MSSM Reprocessed RNASeq"
author: "Thanneer Perumal"
date: "`r date()`"
output: html_document
---
```{r knit2synapse, eval=FALSE}
library(knitr)
library(knit2synapse)
library(synapseClient)

synapseLogin()

knit2synapse::knitToFolderEntity(file = "./PredictPMI.Rmd",
                                 parentId ="syn5569102",
                                 entityName = 'Predict PMI')
```

```{r libs, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE}
## It is assumed your working directory is where this file

## Load required libraries
library(CovariateAnalysis) # get it from devtools::install_github('th1vairam/CovariateAnalysis@dev')
library(data.table)
library(tidyr)
library(plyr)
library(dplyr)
library(stringr)

library(ggplot2)
library(reshape2)
library(limma)
library(Biobase)
library(gplots)
library(WGCNA)
library(psych)
library(edgeR)
library(biomaRt)
library(glmnet)

library(doParallel)
library(foreach)
library(doMC)
library(doParallel)

cl = makeCluster(detectCores() - 2)
registerDoParallel(cl)

options(xtable.type="html")

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE)
```

```{r synapse.parameters, include=FALSE, cache=TRUE}
# Synapse parameters
parentId = 'syn5569102';
activityName = 'Predict PMI';
activityDescription = 'Predict PMI using ROSMAP and MSSM raw counts data';

thisFileName <- 'PredictPMI.Rmd'

# Github link
thisRepo <- getRepo(repository = "th1vairam/Brain_Reg_Net", ref="branch", refName='AMPAD')
thisFile <- getPermlink(repository = thisRepo, repositoryPath=paste0('code/Rmd/',thisFileName))
```
### Data download
#### Obtain count matrix and metadata from synapse.
```{r rosmap.download.data, cache=TRUE}
# Download reprocessed counts (ROSMAP)
COUNT_ROSMAP_ID <- 'syn8020058';
ALL_USED_IDs <- COUNT_ROSMAP_ID
COUNT_ROSMAP <- downloadFile(COUNT_ROSMAP_ID)

# Get design matrix (ROSMAP)
DESIGN_ROSMAP_ID <- 'syn8020068'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = DESIGN_ROSMAP_ID
DESIGN_ROSMAP <- downloadFile(DESIGN_ROSMAP_ID)

# Download reprocessed counts (MSBB)
COUNT_MSBB_ID <- 'syn8074324';
ALL_USED_IDs[length(ALL_USED_IDs)+1] <- COUNT_MSBB_ID
COUNT_MSBB <- downloadFile(COUNT_MSBB_ID)

# Get design matrix (ROSMAP)
DESIGN_MSBB_ID <- 'syn8074328'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = DESIGN_MSBB_ID
DESIGN_MSBB <- downloadFile(DESIGN_MSBB_ID)

# Intersect genes that are common to both ROSMAP and MSBB
ind = intersect(COUNT_ROSMAP$gene.id, COUNT_MSBB$gene.id)

COUNT_ROSMAP = filter(COUNT_ROSMAP, gene.id %in% ind)
rownames(COUNT_ROSMAP) = COUNT_ROSMAP$gene.id
COUNT_ROSMAP$gene.id = NULL

COUNT_MSBB = filter(COUNT_MSBB, gene.id %in% ind)
rownames(COUNT_MSBB) = COUNT_MSBB$gene.id
COUNT_MSBB$gene.id = NULL
COUNT_MSBB = COUNT_MSBB[rownames(COUNT_ROSMAP),]
  
rownames(DESIGN_ROSMAP) = colnames(COUNT_ROSMAP)
rownames(DESIGN_MSBB) = colnames(COUNT_MSBB)
```
Using `r dim(COUNT_ROSMAP)[2]` subjects from the ROSMAP cohorts and `r dim(COUNT_MSBB)[2]` subjects from MSBB cohorts to predict PMI
### Fit model with PMI
```{r w.pmi}
# TMM normalisation
TMM.GENE_EXPRESSION_ROSMAP = calcNormFactors(COUNT_ROSMAP, method = 'TMM')
TMM.GENE_EXPRESSION_MSBB = calcNormFactors(COUNT_MSBB, method = 'TMM')

# Voom normalisation of gene expression
VOOM.GENE_EXPRESSION_ROSMAP = voom(COUNT_ROSMAP, design = DESIGN_ROSMAP,
                                   lib.size = TMM.GENE_EXPRESSION_ROSMAP,
                                   normalize.method = 'quantile')
VOOM.GENE_EXPRESSION_MSBB = voom(COUNT_MSBB, design = DESIGN_MSBB,
                                 lib.size = TMM.GENE_EXPRESSION_MSBB,
                                 normalize.method = 'quantile')

# Fit a linear model
FIT_ROSMAP = lmFit(VOOM.GENE_EXPRESSION_ROSMAP)
FIT_MSBB = lmFit(VOOM.GENE_EXPRESSION_MSBB)

# Find residuals 
RESIDUAL_ROSMAP = residuals.MArrayLM(FIT_ROSMAP, VOOM.GENE_EXPRESSION_ROSMAP$E)
RESIDUAL_MSBB = residuals.MArrayLM(FIT_MSBB, VOOM.GENE_EXPRESSION_MSBB$E)

# Add variable of interest back to the residuals
RESIDUAL_ROSMAP = RESIDUAL_ROSMAP + FIT_ROSMAP$coefficients[,'pmi'] %*% t(DESIGN_ROSMAP[,'pmi'])
RESIDUAL_MSBB = RESIDUAL_MSBB + FIT_MSBB$coefficients[,'PMI'] %*% t(DESIGN_MSBB[,'PMI'])

# Fit linear model using estimated weights and calculate BIC's
BIC.WPMI_ROSMAP = sapply(1:dim(VOOM.GENE_EXPRESSION_ROSMAP$E)[1], function(gene){
  y = VOOM.GENE_EXPRESSION_ROSMAP$E[gene,]
  w = VOOM.GENE_EXPRESSION_ROSMAP$weights[gene,]
  x = DESIGN_ROSMAP
  obj = lm(y~0+., data = cbind(x,data.frame(y=y)), weights = w)
  BIC(obj)
})
names(BIC.WPMI_ROSMAP) = rownames(VOOM.GENE_EXPRESSION_ROSMAP$E)

BIC.WPMI_MSBB = sapply(1:dim(VOOM.GENE_EXPRESSION_MSBB$E)[1], function(gene){
  y = VOOM.GENE_EXPRESSION_MSBB$E[gene,]
  w = VOOM.GENE_EXPRESSION_MSBB$weights[gene,]
  x = DESIGN_MSBB
  obj = lm(y~0+., data = cbind(x,data.frame(y=y)), weights = w)
  BIC(obj)
})
names(BIC.WPMI_MSBB) = rownames(VOOM.GENE_EXPRESSION_MSBB$E)
```
### Fit model with out PMI
```{r wo.pmi}
# Voom normalisation of gene expression
DESIGN_ROSMAP1 = DESIGN_ROSMAP[,setdiff(colnames(DESIGN_ROSMAP), 'pmi')]
VOOM.GENE_EXPRESSION_ROSMAP = voom(COUNT_ROSMAP, design = DESIGN_ROSMAP1, 
                                   lib.size = TMM.GENE_EXPRESSION_ROSMAP,
                                   normalize.method = 'quantile')
DESIGN_MSBB1 = DESIGN_MSBB[,setdiff(colnames(DESIGN_MSBB), 'PMI')]
VOOM.GENE_EXPRESSION_MSBB = voom(COUNT_MSBB, design = DESIGN_MSBB1, 
                                   lib.size = TMM.GENE_EXPRESSION_MSBB,
                                   normalize.method = 'quantile')

# Fit linear model using estimated weights and calculate BIC's
BIC.WOPMI_ROSMAP = sapply(1:dim(VOOM.GENE_EXPRESSION_ROSMAP$E)[1], function(gene){
  y = VOOM.GENE_EXPRESSION_ROSMAP$E[gene,]
  w = VOOM.GENE_EXPRESSION_ROSMAP$weights[gene,]
  x = DESIGN_ROSMAP1
  obj = lm(y~0+., data = cbind(x,data.frame(y=y)), weights = w)
  BIC(obj)
})
names(BIC.WOPMI_ROSMAP) = rownames(VOOM.GENE_EXPRESSION_ROSMAP$E)

BIC.WOPMI_MSBB = sapply(1:dim(VOOM.GENE_EXPRESSION_MSBB$E)[1], function(gene){
  y = VOOM.GENE_EXPRESSION_MSBB$E[gene,]
  w = VOOM.GENE_EXPRESSION_MSBB$weights[gene,]
  x = DESIGN_MSBB1
  obj = lm(y~0+., data = cbind(x,data.frame(y=y)), weights = w)
  BIC(obj)
})
names(BIC.WOPMI_MSBB) = rownames(VOOM.GENE_EXPRESSION_MSBB$E)
```
### Predict PMI
```{r predict.pmi, fig.height=6, fig.width=6}
# Extract features that show improvement in the model with pmi when compared to without pmi
genes_ROSMAP = names(BIC.WOPMI_ROSMAP)[which((BIC.WOPMI_ROSMAP-BIC.WPMI_ROSMAP) >= 6)]
genes_MSBB = names(BIC.WOPMI_MSBB)[which((BIC.WOPMI_MSBB-BIC.WPMI_MSBB) >= 6)]
writeLines(paste(length(genes_ROSMAP),'genes from ROSMAP and',
                 length(genes_MSBB),'genes from MSBB are used as features to predict PMI of which', 
                 length(intersect(genes_MSBB, genes_ROSMAP)), 'are common between ROSMAP and MSBB'))

#### ROSMAP ####
# Extract x and y
x = t(RESIDUAL_ROSMAP[genes_ROSMAP,])
y = DESIGN_ROSMAP$pmi

# Remove samples with 0 pmi
ind = y == 0
x = x[!ind,]
y = log(y[!ind])

# Linear regression model
glm.model = foreach(i = 1:100,
                    .export = c('x','y'),
                    .packages = c('glmnet', 'CovariateAnalysis', 'dplyr', 'plyr')) %dopar% {
  ind = sample(1:length(y), round(length(y)*0.8))
  ind.comp = setdiff(1:length(y), ind)
  
  obj = cv.glmnet(x[ind,],y[ind], family = 'gaussian')
  coeff = as.matrix(coef.glmnet(obj, s = 'lambda.min'))
  ind.var1 = rownames(coeff)
  ind.var2 = setdiff(rownames(coeff)[coeff != 0], '(Intercept)')
  
  # Prune model based on least variable of importance
  while(length(ind.var1) > length(ind.var2)){
    obj1 = cv.glmnet(x[ind,ind.var2],y[ind], family = 'gaussian')
    coeff = as.matrix(coef.glmnet(obj1, s = 'lambda.min'))
    ind.var1 = ind.var2
    ind.var2 = setdiff(rownames(coeff)[coeff != 0], '(Intercept)')
  }
  
  mse = sum((predict(obj1, x[ind.comp,ind.var2], s = 'lambda.min', type = 'response') - y[ind.comp])^2)/length(ind.comp)
  coeff = as.matrix(coef.glmnet(obj1, s = 'lambda.min')) %>%
    rownameToFirstColumn('Coefficients') %>%
    plyr::rename(c('1' = i))
  list(mse = mse, coeff = coeff)
}
boxplot(sapply(glm.model, function(x){x$mse}), main = 'glmnet', ylab = 'mse')
coeff1 = lapply(glm.model, function(x){x$coeff}) %>%
  join_all(type = 'full')
coeff1[is.na(coeff1)] = 0
coeff1 = coeff1[which(rowSums(coeff1[,-(1)] == 0) < 80),]

# Random forest model
rf.model = foreach(i = 1:100,
                .export = c('x','y'),
                .packages = c('ranger', 'CovariateAnalysis', 'dplyr', 'plyr')) %dopar% {
  ind = sample(1:length(y), round(length(y)*0.8))
  ind.comp = setdiff(1:length(y), ind)
  
  obj = ranger(formula = y ~., data = cbind(data.frame(y = y[ind]), x[ind,]), 
               importance = 'permutation',
               write.forest = TRUE)
  coeff = obj$variable.importance
  ind.var1 = names(coeff)
  ind.var2 = names(coeff)[coeff >= abs(min(coeff))]
  
  # Prune model based on least variable of importance
  while(length(ind.var1) > length(ind.var2)){
    obj1 = ranger(formula = y ~., data = cbind(data.frame(y = y[ind]), x[ind,ind.var2]),
                  importance = 'permutation',
                  write.forest = TRUE)
    coeff = obj1$variable.importance
    ind.var1 = ind.var2
    ind.var2 = names(coeff)[coeff >= abs(min(coeff))]
  }
  
  mse = obj1$prediction.error
  coeff = obj1$variable.importance %>%
    rownameToFirstColumn('Coefficients') %>%
    plyr::rename(c('DF' = i))
  list(mse = mse, coeff = coeff)
}
boxplot(sapply(rf.model, function(x){x$mse}), main = 'random forest', ylab = 'mse')
coeff2 = lapply(rf.model, function(x){x$coeff}) %>%
  join_all(type = 'full')
coeff2[is.na(coeff2)] = 0
coeff2 = coeff2[which(rowSums(coeff2[,-(1)] == 0) < 80),]

REG_ROSMAP = coeff1
RF_ROSMAP = coeff2
#### ####

#### MSBB ####
# Extract x and y
x = t(RESIDUAL_MSBB[genes_MSBB,])
y = DESIGN_MSBB$PMI

# Remove samples with 0 pmi
ind = y == 0
x = x[!ind,]
y = log(y[!ind])

# Linear regression model
glm.model = foreach(i = 1:100,
                    .export = c('x','y'),
                    .packages = c('glmnet', 'CovariateAnalysis', 'dplyr', 'plyr')) %dopar% {
  tryCatch({
    ind = sample(1:length(y), round(length(y)*0.8))
    ind.comp = setdiff(1:length(y), ind)
  
    obj = cv.glmnet(x[ind,],y[ind], family = 'gaussian')
    coeff = as.matrix(coef.glmnet(obj, s = 'lambda.min'))
    ind.var1 = rownames(coeff)
    ind.var2 = setdiff(rownames(coeff)[coeff != 0], '(Intercept)')
  
    # Prune model based on least variable of importance
    while(length(ind.var1) > length(ind.var2) & length(ind.var2) > 2){
      obj1 = cv.glmnet(x[ind,ind.var2],y[ind], family = 'gaussian')
      coeff = as.matrix(coef.glmnet(obj1, s = 'lambda.min'))
      ind.var1 = ind.var2
      ind.var2 = setdiff(rownames(coeff)[coeff != 0], '(Intercept)')
    }
    
    mse = sum((predict(obj1, x[ind.comp,ind.var2, drop = F], s = 'lambda.min', type = 'response') - y[ind.comp])^2)/length(ind.comp)
    coeff = as.matrix(coef.glmnet(obj1, s = 'lambda.min')) %>%
      rownameToFirstColumn('Coefficients') %>%
      plyr::rename(c('1' = i))
    list(mse = mse, coeff = coeff)
  }, error = function(e){
     list(mse = NA, coeff = NA) 
  })
}
boxplot(sapply(glm.model, function(x){x$mse}), main = 'glmnet', ylab = 'mse')
coeff1 = lapply(glm.model, function(x){x$coeff}) %>%
  join_all(type = 'full')
coeff1[is.na(coeff1)] = 0
coeff1 = coeff1[which(rowSums(coeff1[,-(1)] == 0) < 80),]

# Random forest model
rf.model = foreach(i = 1:100,
                .export = c('x','y'),
                .packages = c('ranger', 'CovariateAnalysis', 'dplyr', 'plyr')) %dopar% {
  ind = sample(1:length(y), round(length(y)*0.8))
  ind.comp = setdiff(1:length(y), ind)
  
  obj = ranger(formula = y ~., data = cbind(data.frame(y = y[ind]), x[ind,]), 
               importance = 'permutation',
               write.forest = TRUE)
  coeff = obj$variable.importance
  ind.var1 = names(coeff)
  ind.var2 = names(coeff)[coeff >= abs(min(coeff))]
  
  # Prune model based on least variable of importance
  while(length(ind.var1) > length(ind.var2)){
    obj1 = ranger(formula = y ~., data = cbind(data.frame(y = y[ind]), x[ind,ind.var2]),
                  importance = 'permutation',
                  write.forest = TRUE)
    coeff = obj1$variable.importance
    ind.var1 = ind.var2
    ind.var2 = names(coeff)[coeff >= abs(min(coeff))]
  }
  
  mse = obj1$prediction.error
  coeff = obj1$variable.importance %>%
    rownameToFirstColumn('Coefficients') %>%
    plyr::rename(c('DF' = i))
  list(mse = mse, coeff = coeff)
}
boxplot(sapply(rf.model, function(x){x$mse}), main = 'random forest', ylab = 'mse')
coeff2 = lapply(rf.model, function(x){x$coeff}) %>%
  join_all(type = 'full')
coeff2[is.na(coeff2)] = 0
coeff2 = coeff2[which(rowSums(coeff2[,-(1)] == 0) < 80),]

REG_MSBB = coeff1
RF_MSBB = coeff2
#### ####
```

### Store results in synapse
```{r syn.store}
# Create folder to store results in synapse
CODE = Folder(name = 'Predict PMI', parentId = parentId)
CODE = synStore(CODE)

# Store features in synapse (union of all models)
tmp = setdiff(unique(c(REG_ROSMAP$Coefficients, REG_MSBB$Coefficients, RF_ROSMAP$Coefficients, RF_MSBB$Coefficients)), '(Intercept)')
write.table(tmp, file = 'features.tsv', sep = '\n', row.names = F, quote=F)
obj = File('features.tsv', name = 'Predictors of PMI', parentId = CODE$properties$id)
obj = synStore(obj, used = as.character(ALL_USED_IDs), executed = thisFile, 
               activityName = activityName, activityDescription = activityDescription)

# Store coefficients in synapse
save(REG_ROSMAP, REG_MSBB, RF_ROSMAP, RF_MSBB, file = 'coeffPMI.RData')
obj = File('coeffPMI.RData', name = 'Coefficients of all models', parentId = CODE$properties$id)
obj = synStore(obj, used = as.character(ALL_USED_IDs), executed = thisFile, 
               activityName = activityName, activityDescription = activityDescription)
stopCluster(cl)
```